#!/bin/sh
# This is sourced. Fake bang-path to help editors and linters
#  shellcheck disable=SC2034 # this defines a lot of things for other scripts
#
#  Part of https://github.com/jaclu/ish-fstool
#
#  License: MIT
#
#  Copyright (c) 2023-2025: Jacob.Lundqvist@gmail.com
#
#  Environment variables used when building ish-fstools
#

#---------------------------------------------------------------
#
#   Notifications
#
#  The msg_ functions are ordered, lower number infers more important updates
#  so they should stand out more
#
#---------------------------------------------------------------

err_msg() {
    #  Display an error message, second optional param is exit code,
    #  defaulting to 1. If exit code is -1 this will not exit, just display
    #  the error message and continue.
    _em_msg="$1"
    _em_exit_code="${2:-1}"
    if [ -z "$_em_msg" ]; then
        # Don't use log_it here, to avoid risk of infinite recursion...
        echo
        echo "err_msg() no param"
        exit 9
    fi

    _em_msg="ERROR[$0]: $_em_msg"
    echo
    echo "$_em_msg"
    echo

    if [ "$_em_exit_code" -gt -1 ]; then
        exit "$_em_exit_code"
    fi
    unset _em_msg
    unset _em_exit_code
}

log_it() {
    _li_msg="$1"

    [ -z "$_li_msg" ] && err_msg "log_it() no param"

    if [ -c /dev/stderr ]; then
        echo "$_li_msg" >/dev/stderr
    else
        echo "GLITCH: /dev/stderr is failing!!"
        echo "$_li_msg"
        exit 12
    fi

    unset _li_msg
}

lbl_1() {
    [ -z "$1" ] && err_msg "lbl_1() no param"
    echo
    log_it "===  $1  ==="
    echo
}

lbl_2() {
    [ -n "$1" ] || err_msg "lbl_2() no param"
    log_it "---  $1"
}

lbl_3() {
    [ -n "$1" ] || err_msg "lbl_3() no param"
    log_it " --  $1"
}

lbl_4() {
    [ -n "$1" ] || err_msg "lbl_4() no param"
    log_it "  -  $1"
}

msg_dbg() {
    [ -n "$1" ] || err_msg "msg_dbg() no param"
    log_it "><>  $1"
}

syslog() {
    [ -z "$1" ] && error_msg "syslog() - called without param"

    /usr/local/bin/logger "$(basename "$0")" "$1"
}

#---------------------------------------------------------------
#
#   File checks
#
#---------------------------------------------------------------

was_sys_path() {
    case "$1" in
        /tmp/* | /var/tmp/* | "$TMPDIR"/*) return 1;; # tmpf files can be removed
        /bin | /bin/* | /boot | /boot/* | /dev | /dev/* | /etc | /etc/* | /home | \
            "$HOME" | /lib | /lib/* | /lib64 | /lib64/* | /lost+found | /lost+found/* | \
            /media | /media/* | /mnt | /mnt/* | /opt | /opt/* | /proc | /proc/* | \
            /run | /run/* | /sbin | /sbin/* | /sys | /sys/* | /tmp | \
            /usr | /usr/* | /var | /var/* | /Users) return 0 ;;
        *) ;;
    esac
    return 1
}

safe_remove() {
    #
    # if item is a folder it is just cleared, unless it is prefixed with --remove-dir
    # then the entie folder is removed
    # Anyhing containing a sys path is rejected, unless --ignore-sys-path is supplied
    #

    # Param parsing
    _sr_remove_dir=false
    _sr_check_sys_path=true

    while [ -n "$1" ]; do
        case "$1" in
            -r | --remove-dir) _sr_remove_dir=true ;;
            --ignore-sys-path) _sr_check_sys_path=false ;;
            -*) err_msg "Unknown option: $1" ;;
            *) break ;;
        esac
        shift
    done

    _sr_item=$1
    [ -z "$_sr_item" ] && err_msg "delete_item: missing path"

    $_sr_check_sys_path && was_sys_path "$_sr_item" && {
        err_msg "Refusing to remove a sys-path: $_sr_item"
    }

    if [ -d "$_sr_item" ]; then
        mount | grep "$_sr_item" && {
            err_msg "safe_remove() - this is a mount point: $_sr_item"
        }
        if $_sr_remove_dir; then
            rm -rf -- "$_sr_item" || err_msg "Failed to remove directory: $_sr_item"
            lbl_2 "Removed directory: $_sr_item"
        else
            # shellcheck disable=SC2115 # _sr_item is already checked for being empty
            rm -rf -- "$_sr_item"/* "$_sr_item"/.??* 2>/dev/null || {
                err_msg "Failed to clear directory: $_sr_item"
            }
            lbl_2 "Cleared directory: $_sr_item"
        fi
        return
    fi

    if [ -f "$_sr_item" ]; then
        rm -f -- "$_sr_item" || err_msg "Failed to remove file: $_sr_item"
        lbl_4 "Removed file: $_sr_item"
    fi
}

#---------------------------------------------------------------
#
#   boolean checks
#
#---------------------------------------------------------------

is_ish() {
    [ -d /proc/ish ]
}

fs_is_alpine() {
    test -f /etc/alpine-release
}

fs_is_debian() {
    test -f /etc/debian_version && ! fs_is_devuan
}

fs_is_devuan() {
    test -f /etc/devuan_version
}

fs_is_gentoo() {
    test -f /etc/gentoo-release
}

is_fs_chrooted() {
    # cmdline check:
    # grep -qv " / / " /proc/self/mountinfo || echo "is chrooted"

    # this quick and simple check doesn't work on ish
    # so lets pretend for now chroot does not happen on ish
    is_ish && return 1                       # would never happen here :)
    [ "$(uname -s)" != "Linux" ] && return 1 # can only chroot this on Linux
    ! grep -q " / / " /proc/self/mountinfo
}

#===============================================================
#
#   Main
#
#===============================================================

# these must be done before local variables assignments,
# since some of them depend on variables defined by them
# read_config
# check_if_host_or_dest_fs

#
#  Locations for various stuff
#

TMPDIR="${TMPDIR:-/tmp}"

# Set base repo directory
d_repo="{{ d_repo | default('/opt/ish-fstools') }}"

d_ift_etc_opt=/etc/opt/ift

#  file alt hostname reads to find hostname
#  the variable has been renamed to

#
#  For automated logins used by ift anf ift-launcher
#
f_login_default_user="$d_ift_etc_opt"/login-default-username
f_logins_continuous="$d_ift_etc_opt"/login-continuous

f_pts_0_as_console="$d_ift_etc_opt"/pts_0_as_console
f_profile_hints="$d_ift_etc_opt"/show_profile_hints

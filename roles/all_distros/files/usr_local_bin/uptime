#!/bin/sh
#
#  Part of https://github.com/jaclu/ish-fstool
#
#  Copyright (c) 2024: Jacob.Lundqvist@gmail.com
#
#  License: MIT
#
#  This serves two purposes:
#
#  1> If lines like: ===  System startup  ===
#     can be found in /var/log/syslog, the corresponding timestamp for
#     the last match will be assumed to be iSH boot time,
#     (this will be off by a few seconds from actual iSH startup).
#     Those lines are generated by the ish-fstools inittab and ift-launcher.
#     If it is not found this fallbacks to iOS boot time via /proc/uptime
#     for Debian and for Alpine, the regular uptime is run instead showing
#     the same iOS boot time.
#
#  2> iSH doesn't currently provide /proc/loadavg
#     Debian's regular uptime fails badly - (because of no /proc/loadavg??)
#     therefore sysload is faked, always reporting 0.00, 0.00, 0.00
#     On Alpine the BusyBox uptime can report sysload, so sysload is
#     extracted via /usr/bin/uptime.
#

show_help() {
    #region help text
    cat <<EOF
Usage:
 $app_name [options]

Options:
 -h, --help     display this help and exit
 -p, --pretty   show uptime in pretty format
 -s, --since    system up since
 -V, --version  output version information and exit

<* non-standard options *>
 -i, --ios      display iOS instead of iSH uptime
 -l, --load     displays only sysload
For more details see uptime(1).
EOF
    #endregion
    exit 0
}

is_busybox_uptime() {
    [ -x "$cmd_busybox" ] && [ "$(realpath /usr/bin/uptime)" = "$cmd_busybox" ]
}

org_uptime() {
    $dbg && log_it "org_uptime()"

    # 1 check if it is not a softlink to busybox, if so abort
    [ -x "$cmd_org_uptime" ] && [ ! -L "$cmd_org_uptime" ] && {
        err_msg "$cmd_org_uptime needs to be softlinked to /bin/busybox on iSH"
    }

    [ ! -x "$cmd_org_uptime" ] && {
        if [ -x "$cmd_busybox" ]; then
            echo "Linking $cmd_org_uptime to busybox"
            ln -sf "$cmd_busybox" "$cmd_org_uptime"
        else
            echo "ERROR: $cmd_org_uptime unavailable!"
            exit 1
        fi
    }

    [ "$(realpath "$cmd_org_uptime")" = "$(realpath "$0")" ] && {
        echo "ERROR: $cmd_org_uptime points to this replacement uptime!"
        exit 1
    }
    $dbg && msg_2 "org_uptime() - running org_uptime"
    $cmd_org_uptime
}

calculate_ish_uptime() {
    $dbg && log_it "calculate_ish_uptime()"
    boot_time_epoch=$(date -d "$time_stamp_boot_up" +%s)
    current_time=$(date +%s)
    uptime_seconds=$((current_time - boot_time_epoch))
}

calculate_ios_uptime() {
    $dbg && log_it "calculate_ios_uptime()"

    # shellcheck disable=SC2046  # Suppresses warnings about quoting
    set -- $("$cmd_org_uptime")
    while [ "$1" != "up" ] && [ "$#" -gt 0 ]; do shift; done
    shift

    rest=$*
    rest=${rest%%load*}
    rest=${rest%,}

    old_ifs=$IFS
    IFS=,
    # shellcheck disable=SC2086  # Suppresses warnings about quoting
    set -- $rest
    IFS=$old_ifs

    t_days=$1
    t_hm=$2
    case $t_days in
    *" days"*) t_days=${t_days%" days"} ;;
    *)
        t_hm=$t_days
        t_days=0
        ;;
    esac

    # Trim leading/trailing spaces in t_hm (POSIX-safe)
    t_hm=${t_hm## }  # leading
    t_hm=${t_hm%% }  # trailing

    # Default days to 0 if empty (paranoia)
    [ -z "$t_days" ] && t_days=0

    # Split HH:MM
    old_ifs=$IFS
    IFS=:
    # shellcheck disable=SC2086  # Suppresses warnings about quoting
    set -- $t_hm
    IFS=$old_ifs

    h=$1
    m=$2

    # Default hour/minute fallback (in case uptime says "X min")
    case $m in
      "")
        m=$h
        h=0 ;;
      *) ;;
    esac
    uptime_seconds=$((t_days * 86400 + h * 3600 + m * 60))

    # $cmd_org_uptime | cut -d',' -f1,2
    # uptime_raw=$(cut -d' ' -f1 </proc/uptime)
    # uptime_seconds=$(echo "$uptime_raw" | awk '{print int($1)}')
}

calculate_uptime() {
    $dbg && log_it "calculate_uptime()"
    startup_notice="===  System startup  ==="
    if [ -f /var/log/syslog ]; then
        time_stamp_boot_up="$(grep "$startup_notice" /var/log/syslog |
            tail -n 1 |
            awk '{print $1" "$2}')"
    else
        time_stamp_boot_up=""
    fi
    if [ -n "$time_stamp_boot_up" ] && ! $force_ios_uptime; then
        calculate_ish_uptime
    else
        calculate_ios_uptime
    fi

    $dbg && msg_2 "calculate_uptime() - doing the calculations"
    # Calculate days, hours, minutes
    ut_days=$((uptime_seconds / 86400))
    ut_hours=$(((uptime_seconds % 86400) / 3600))
    ut_minutes=$(((uptime_seconds % 3600) / 60))
}

display_sysload() {
    $dbg && log_it "display_sysload()"
    if [ -f /etc/alpine-release ]; then
        $dbg && msg_2 "display_sysload() - using org_uptime"
        org_uptime | sed 's/load average: /|/' | cut -d'|' -f 2
    else
        echo "0.00, 0.00, 0.00"
    fi
}

get_user_count()
{
    user_count=0
    seen=""

    $dbg && log_it "get_user_count()"
    tmpfile=$(mktemp)

    [ "$(realpath /bin/ps)" = /bin/busybox ] && err_msg "this uptime needs procps"
    # -eo tty lists all TTYs (including '?', '', etc.)
    # strip header with a `read` call
    ps -eo tty > "$tmpfile"
    {
        read -r _ # skip header
        while read -r tty; do
            case "$tty" in
                pts/*)
                    case " $seen " in
                        *" $tty "*)
                            ;; # already counted
                        *)
                            seen="$seen $tty";
                            user_count=$((user_count + 1))
                            ;;
                    esac
                    ;;
                *) ;;
            esac
        done
    } < "$tmpfile"
    rm -f "$tmpfile"
}

default_view() {
    $dbg && log_it "default_view()"

    $force_ios_uptime && [ -f "$cmd_org_uptime" ] && {
        $cmd_org_uptime
        exit "$?"
    }

    calculate_uptime

    _minutes=$(printf "%02d" "$ut_minutes")
    _hours=$(printf "%d" "$ut_hours")

    output="$ut_minutes min"
    [ "$ut_hours" -gt 0 ] && output="$_hours:$_minutes"
    [ "$ut_days" -gt 0 ] && output="$ut_days days, $output"

    get_user_count
    user_field="$user_count user"
    [ "$user_count" -gt 1 ] && user_field="${user_field}s"

    $dbg && msg_2 "default_view() - create output [$output] [$user_field]"
    _s=" $(date +%H:%M:%S) up $output,  $user_field,  load average:"
    _s="$_s $(display_sysload)"
    echo "$_s"
}

show_pretty() {
    $dbg && log_it "show_pretty()"

    calculate_uptime

    output="$ut_minutes minutes"
    [ "$ut_hours" -gt 0 ] && output="$ut_hours hours, $output"
    [ "$ut_days" -gt 0 ] && output="$ut_days days, $output"
    echo "up $output"
}

show_since() {
    $dbg && log_it "show_since($uptime_seconds)"

    calculate_uptime

    if [ -f /etc/alpine-release ]; then
        current_timestamp=$(date +%s)
        new_timestamp=$((current_timestamp - uptime_seconds))
        date -u -d "@$new_timestamp" "+%Y-%m-%d %H:%M:%S"
    else
        date -d "$uptime_seconds seconds ago" "+%Y-%m-%d %H:%M:%S"
    fi
}

show_version() {
    $dbg && log_it "show_version()" >/dev/stder
    if $force_ios_uptime && is_busybox_uptime; then
        $cmd_busybox uptime -V 2>&1 | grep ^BusyBox
    else
        _f=/etc/ish-fstools-release
        ish_fstools_vers=$(cat "$_f" 2>/dev/null || echo "unknown ish-fstools version")
        echo "uptime from ish-fstools $ish_fstools_vers"
    fi
    exit 0
}

#===============================================================
#
#   Main
#
#===============================================================

app_name="$(basename "$0")"

# For debugging when not using this FS
# . /opt/ish-fstools/tools/utils.sh

# shellcheck source=/opt/ish-fstools/roles/all_distros/templates/ift-utils.sh.js2
. /usr/local/lib/ift-utils.sh

cmd_org_uptime=/usr/bin/uptime
cmd_busybox=/bin/busybox

#  Defaults for boolean options
force_ios_uptime=false
display_mode="default"
dbg=false

while [ -n "$1" ]; do
    case "$1" in
    # -h | --help) show_help ;;
    -d) dbg=true ;;
    -i | --ios) force_ios_uptime=true ;;
    -l | --load) display_mode="load" ;;
    -p | --pretty) display_mode="pretty" ;;
    -s | --since) display_mode="since" ;;
    -V | --version) display_mode="version" ;;
    *)
        msg_1 "$app_name: invalid option -- '$1'"
        show_help
        ;;
    esac
    shift
done

case "$display_mode" in
version) show_version ;;
default) default_view ;;
pretty) show_pretty ;;
since) show_since ;;
load) display_sysload ;;
*) err_msg "Invalid display_mode [$display_mode]" ;;
esac

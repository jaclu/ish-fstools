#!/bin/sh
#
#  Part of https://github.com/jaclu/ish-fstool
#
#  Copyright (c) 2024: Jacob.Lundqvist@gmail.com
#
#  License: MIT
#
#  This serves two purposes:
#
#  1> If lines like: ===  System startup  ===
#     can be found in /var/log/syslog, the corresponding timestamp for
#     the last match will be assumed to be iSH boot time,
#     (this will be off by a few seconds from actual iSH startup).
#     Those lines are generated by the AOK inittab and ift-launcher.
#     If it is not found this fallbacks to iOS boot time via /proc/uptime
#     for Debian and for Alpine, the regular uptime is run instead showing
#     the same iOS boot time.
#
#  2> iSH doesn't currently provide /proc/loadavg
#     Debian's regular uptime fails badly - (because of no /proc/loadavg??)
#     therefore sysload is faked, always reporting 0.00, 0.00, 0.00
#     On Alpine the BusyBox uptime can report sysload, so sysload is
#     extracted via /usr/bin/uptime.
#

show_help() {
    #region help text
    cat <<EOF
Usage:
 $app_name [options]

Options:
 -p, --pretty   show uptime in pretty format
 -h, --help     display this help and exit
 -s, --since    system up since
 -V, --version  output version information and exit

<* non-standard options *>
 -i, --ios      display iOS instead of iSH uptime
 -l, --load     displays only sysload
For more details see uptime(1).
EOF
    #endregion
    exit 0
}

is_busybox_uptime() {
    [ -x "$cmd_busybox" ] && [ "$(realpath /usr/bin/uptime)" = "$cmd_busybox" ]
}

org_uptime() {
    $dbg && echo ">org_uptime()" >/dev/stderr

    [ ! -x "$cmd_org_uptime" ] && {
        if [ -x "$cmd_busybox" ]; then
            echo "Linking $cmd_org_uptime to busybox"
            ln -sf "$cmd_busybox" "$cmd_org_uptime"
        else
            echo "ERROR: $cmd_org_uptime unavailable!"
            exit 1
        fi
    }

    [ "$(realpath "$cmd_org_uptime")" = "$(realpath "$0")" ] && {
        echo "ERROR: $cmd_org_uptime points to this replacement uptime!"
        exit 1
    }
    $dbg && echo ">org_uptime() - running org_uptime" >/dev/stderr
    $cmd_org_uptime
}

calculate_ish_uptime() {
    $dbg && echo ">calculate_ish_uptime()" >/dev/stderr
    boot_time_epoch=$(date -d "$time_stamp_boot_up" +%s)
    current_time=$(date +%s)
    uptime_seconds=$((current_time - boot_time_epoch))
}

calculate_ios_uptime() {
    log_it "calculate_ios_uptime()"

    # shellcheck disable=SC2046  # Suppresses warnings about quoting
    set -- $("$cmd_org_uptime")
    while [ "$1" != "up" ] && [ "$#" -gt 0 ]; do shift; done
    shift

    rest=$*
    rest=${rest%%load*}
    rest=${rest%,}

    old_ifs=$IFS
    IFS=,
    # shellcheck disable=SC2086  # Suppresses warnings about quoting
    set -- $rest
    IFS=$old_ifs

    t_days=$1
    t_hm=$2
    case $t_days in
    *" days"*) t_days=${t_days%" days"} ;;
    *)  t_hm=$t_days
        t_days=0
        ;;
    esac

    # Trim leading/trailing spaces in t_hm (POSIX-safe)
    t_hm=${t_hm## }  # leading
    t_hm=${t_hm%% }  # trailing

    # Default days to 0 if empty (paranoia)
    [ -z "$t_days" ] && t_days=0

    # Split HH:MM
    old_ifs=$IFS
    IFS=:
    # shellcheck disable=SC2086  # Suppresses warnings about quoting
    set -- $t_hm
    IFS=$old_ifs

    h=$1
    m=$2

    # Default hour/minute fallback (in case uptime says "X min")
    case $m in
      "") m=$h; h=0 ;;
      *) ;;
    esac
    msg_4 "t_days[$t_days] t_hm[$t_hm] h[$h] m[$m]"
    uptime_seconds=$((t_days * 86400 + h * 3600 + m * 60))
    msg_4 "seconds:$uptime_seconds"

    # $cmd_org_uptime | cut -d',' -f1,2
    # uptime_raw=$(cut -d' ' -f1 </proc/uptime)
    # uptime_seconds=$(echo "$uptime_raw" | awk '{print int($1)}')
}

calculate_uptime() {
    startup_notice="===  System startup  ==="
    log_it "calculate_uptime()"
    if [ -f /var/log/syslog ]; then
        time_stamp_boot_up="$(grep "$startup_notice" /var/log/syslog |
            tail -n 1 |
            awk '{print $1" "$2}')"
    else
        time_stamp_boot_up=""
    fi
    if [ -n "$time_stamp_boot_up" ] && ! $force_ios_uptime; then
        calculate_ish_uptime
    else
        calculate_ios_uptime
    fi

    $dbg && echo ">calculate_uptime() - doing the calculations" >/dev/stderr
    # Calculate days, hours, minutes
    ut_days=$((uptime_seconds / 86400))
    ut_hours=$(((uptime_seconds % 86400) / 3600))
    ut_minutes=$(((uptime_seconds % 3600) / 60))
}

display_sysload() {
    $dbg && echo ">display_sysload()" >/dev/stderr
    if [ -f /etc/alpine-release ]; then
        $dbg && echo ">display_sysload() - using org_uptime" >/dev/stderr
        org_uptime | sed 's/load average: /|/' | cut -d'|' -f 2
    else
        echo "0.00, 0.00, 0.00"
    fi
}

default_view() {
    log_it "default_view()"

    $force_ios_uptime && [ -f "$cmd_org_uptime" ] && {
        msg_2 "using: $cmd_org_uptime"
        $cmd_org_uptime
        exit "$?"
    }

    calculate_uptime

    _minutes=$(printf "%02d" "$ut_minutes")
    _hours=$(printf "%d" "$ut_hours")

    output="$ut_minutes min"
    [ "$ut_hours" -gt 0 ] && output="$_hours:$_minutes"
    [ "$ut_days" -gt 0 ] && output="$ut_days days, $output"

    user_count=$(find /dev/pts/* | wc -l)
    user_field="$user_count user"
    [ "$user_count" -gt 1 ] && user_field="${user_field}s"

    $dbg && echo ">default_view() - create output [$output] [$user_field]" >/dev/stderr
    _s=" $(date +%H:%M:%S) up $output,  $user_field,  load average:"
    _s="$_s $(display_sysload)"
    echo "$_s"
}

show_pretty() {
    $dbg && echo ">show_pretty()" >/dev/stderr

    calculate_uptime

    output="$ut_minutes minutes"
    [ "$ut_hours" -gt 0 ] && output="$ut_hours hours, $output"
    [ "$ut_days" -gt 0 ] && output="$ut_days days, $output"
    echo "up $output"
}

show_since() {
    $dbg && echo ">show_since($uptime_seconds)" >/dev/stderr

    calculate_uptime

    if [ -f /etc/alpine-release ]; then
        current_timestamp=$(date +%s)
        new_timestamp=$((current_timestamp - uptime_seconds))
        date -u -d "@$new_timestamp" "+%Y-%m-%d %H:%M:%S"
    else
        date -d "$uptime_seconds seconds ago" "+%Y-%m-%d %H:%M:%S"
    fi
}

show_version() {
    $dbg && echo ">show_version()" >/dev/stder
    if $force_ios_uptime && is_busybox_uptime; then
        $cmd_busybox uptime -V 2>&1 | grep ^BusyBox
    else
        _f=/etc/aok-fs-release
        aok_vers=$(cat "$_f" 2>/dev/null || echo "unknown AOK-FS version")
        echo "uptime from AOK-FS $aok_vers"
    fi
    exit 0
}

#===============================================================
#
#   Main
#
#===============================================================

app_name="$(basename "$0")"

# d_repo="$(dirname -- "$(dirname -- "$(realpath "$0")")")"
# . /opt/ish-fstools/tools/utils.sh

# shellcheck source=/opt/ish-fstools/roles/all_distros/templates/ift-utils.sh.js2
. /usr/local/lib/ift-utils.sh

cmd_org_uptime=/usr/bin/uptime
cmd_busybox=/bin/busybox

#  Defaults for boolean options
force_ios_uptime=false
display_mode="default"
dbg=false

while [ -n "$1" ]; do
    case "$1" in
    # -h | --help) show_help ;;
    -d) dbg=true ;;
    -i | --ios) force_ios_uptime=true ;;
    -l | --load) display_mode="load" ;;
    -p | --pretty) display_mode="pretty" ;;
    -s | --since) display_mode="since" ;;
    -V | --version) display_mode="version" ;;
    *)
        echo "uptime: invalid option -- '$1'"
        show_help
        ;;
    esac
    shift
done

case "$display_mode" in
version) show_version ;;
default) default_view ;;
pretty) show_pretty ;;
since) show_since ;;
load) display_sysload ;;
*)
    echo "Invalid display_mode [$display_mode]"
    ;;
esac
